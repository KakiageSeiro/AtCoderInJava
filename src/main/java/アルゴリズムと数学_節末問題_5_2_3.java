import java.util.Arrays;
import java.util.Scanner;

public class アルゴリズムと数学_節末問題_5_2_3 {
    public static void main() {
        // ■■■■■■■■■■■■■■■■■■■■

        Scanner sc = new Scanner(System.in);

        int n街の数 = sc.nextInt();
        long kテレポート回数 = sc.nextLong();

        int[] aテレポート先 = new int[n街の数 + 1];
        for (int i = 1; i <= n街の数; i++) {
            aテレポート先[i] = sc.nextInt();
        }

        // 1 最初

        // 3
        // 4
        // 1
        // 3
        // 4 5回移動後の街

        long[] f最初に街を訪れたときのテレポート回数 = new long[n街の数 + 1];
        long[] s二回目に街を訪れたときのテレポート回数 = new long[n街の数 + 1];

        Arrays.fill(f最初に街を訪れたときのテレポート回数, -1L);
        Arrays.fill(s二回目に街を訪れたときのテレポート回数, -1L);

        long t現在のテレポート回数 = 0L;
        int m現在の街 = 1;
        while (true) {
            if (f最初に街を訪れたときのテレポート回数[m現在の街] == -1L) {
                f最初に街を訪れたときのテレポート回数[m現在の街] = t現在のテレポート回数;
            } else if (s二回目に街を訪れたときのテレポート回数[m現在の街] == -1L) {
                s二回目に街を訪れたときのテレポート回数[m現在の街] = t現在のテレポート回数;
            }

            // 目的回数移動後(ゴール)の場合
            if (t現在のテレポート回数 == kテレポート回数) {
                System.out.println(m現在の街);
                return;
            }

            // 三回以上訪れていないと、周期が不明なため、周期を複数回繰り返した未来でたどり着くかどうか判定出来ない
            boolean 三回以上訪れている = s二回目に街を訪れたときのテレポート回数[m現在の街] != -1L;

            long 周期 = s二回目に街を訪れたときのテレポート回数[m現在の街] - f最初に街を訪れたときのテレポート回数[m現在の街];
            long 周期に入るまでを除外した残りテレポート回数 = kテレポート回数 - f最初に街を訪れたときのテレポート回数[m現在の街];
            boolean 周期に従えばいずれたどり着く = 周期に入るまでを除外した残りテレポート回数 % 周期 == 0;

            if (三回以上訪れている && 周期に従えばいずれたどり着く) {
                System.out.println(m現在の街);
                return;
            }

            // 位置の更新
            m現在の街 = aテレポート先[m現在の街];
            t現在のテレポート回数++;
        }


        // ■■■■■■■■■■■■■■■■■■■■
    }
}

